<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>17-445: Trade-offs among AI Techniques</title>
    <link rel="stylesheet" href="./../css/reveal.css" />
    <link rel="stylesheet" href="./../css/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./../css/highlight/zenburn.css" />
    <link rel="stylesheet" href="./../css/print/paper.css" type="text/css" media="print" />
    <link rel="stylesheet" href="./../_assets/_assets/cmu.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><div id="footer">17-445 Software Engineering for AI-Enabled Systems, Eunsuk Kang</div><section  data-markdown><script type="text/template">  

# Trade-offs among AI Techniques

Eunsuk Kang

<!-- references -->

Required reading: Hulten, Geoff. "Building Intelligent Systems: A
Guide to Machine Learning Engineering." (2018), Chapters 6, 7, and 24.
</script></section><section  data-markdown><script type="text/template"># Learning Goals

* Understand the major types of ML tasks and learning methods

* Organize and prioritize the relevant qualities of concern for a given project

* Plan and execute an evaluation of the qualities of alternative AI techniques for a given purpose
</script></section><section ><section data-markdown><script type="text/template"># Selection
</script></section><section data-markdown><script type="text/template">## AI != Deep Learning

![AI vs ML](AIvsML.jpg)

(In this lecture, we will focus on ML)
</script></section><section data-markdown><script type="text/template">## ML Methods

![ml-methods-poll](ml-methods-poll.jpg)
</script></section><section data-markdown><script type="text/template"># Selection

## How do I decide which ML technique to use for my project?
</script></section><section data-markdown><script type="text/template">## Criteria: Attributes & Constraints

* Attributes 
  * Quality attributes: What the user experiences 
	* Performance, reliability, availability...
  * Project attributes: Time-to-market, development & HR cost
  * Design attributes: Type of ML method used, accuracy, training
    time, prediction time, memory usage
* Constraints: What you must satsify
  * Problem constraints: What the product must provide to the user
  * Project constraints: Deadline, project budget, available skills
  * Design constraints: Type of ML task required, limits on computing resources, data
	availability
</script></section></section><section ><section data-markdown><script type="text/template"># Types of ML Tasks
</script></section><section data-markdown><script type="text/template">## ML Tasks

* Classification
* Regression
* Clustering
* (Dimensionality reduction)
</script></section><section data-markdown><script type="text/template">## Classification

![spam-filter](spam-filter.png)

* Which one of the given categories does a new
observation belong to?
	* e.g., e-mail spam filter, pedestrian detection
	* Output is a _categorical_ value
</script></section><section data-markdown><script type="text/template">## Regression

![hurricane](hurricane.gif)

* What is the estimated value for an output given an observation?
	* e.g., weather forecasting, sales prediction
	* Output is a _numercal/continuous_ value
</script></section><section data-markdown><script type="text/template">## Clustering

![social-network](social-network.jpg)

* What is the best way to divide a set of observations into
distinct groups?
	* Output is a set of categories 
	* e.g., human genetic clustering, social network analysis

<!-- references -->

_An Exploration of Social Identity: The Geography and Politics of
News-Sharing Communities in Twitter_, Herdagdelen et al. (2012)
</script></section><section data-markdown><script type="text/template">## Example: Product Recommendation

![Product recommendations](recommendations.png)

### Q. What type of ML task(s) does the system perform?
</script></section></section><section ><section data-markdown><script type="text/template"># Attributes of ML Methods
</script></section><section data-markdown><script type="text/template">## Attributes 

* Type of ML task: Classification, regression, or clustering?
* Type of data required
  * Labeled vs. not labeled
  * Categorical vs. numerical
* Accuracy: (Number of correct predictions) / (Total number of predictions)
* Interpretability: Why did the model make decision X?
* Complexity
   * Linear vs. non-linear relationship between input & output variables
   * Number of features
* Training costs
  * Amount of training data required to reach high accuracy
  * Training time
* Model size: Can you store all your model in memory?
* Incrementality: Can you improve the model by gradually adding more data?
* Inference time: How long does it take for the model to make a decision?
</script></section><section data-markdown><script type="text/template">## Accuracy for Binary Classification

![accuracy-metrics](accuracy-metrics.jpg)

* Recall = TP / (actual positive) = TP/ (TP + FN)
* Precision = FP / (actual negatives) = FP / (TN + FP)
</script></section></section><section ><section data-markdown><script type="text/template"># Types of ML Methods
</script></section><section data-markdown><script type="text/template">## Linear Regression

![linear-regression](linear-regression.png)

* Tasks: Regression 
* Linear relationship between input & output variables
* Easy to interpret, low training cost, small model size
* Can't capture non-linear relationships well
</script></section><section data-markdown><script type="text/template">## Decision Tree Learning

![decision-tree-fraud](credit-card-fraud.png)

* Tasks: Classification & regression
* Non-leaft nodes: Conditional on input variables
* Leaf nodes: Class labels or continuous output values
* Easy to interpret; can capture non-linearity; can do well with
  little data
* Low accuracy (high risk of overfitting); possibly very large tree size
</script></section><section data-markdown><script type="text/template">## Neural Network

![neural-network](neural-network.png)

* Tasks: Classification & regression
* High accuracy; can capture a wide range of problems (linear & non-linear)
* Difficult to interpret; high training costs (time & amount of
  data required, hyperparameter tuning)
</script></section><section data-markdown><script type="text/template">## k-Nearest Neighbors (kNN)

![knn](knn.png)

* Tasks: Classification & regression
* Infer the class/property of an object based on that of _k_ nearest neighbors
* _Lazy learning_: Generalization is delayed until
  the inference takes place 
* Easy to interpret; little training costs (due to lazy learning)
* Potentially slow inference (again, due to lazy learning); high data storage
  requirement (must store all training instances)

<!-- ---- -->
<!-- ## K-Means Clustering -->

<!-- ![k-means](k-means.png) -->

<!-- * Task: Clustering -->
<!-- * Fast (for small _k_) -->
<!-- * Manual choice of _k_ -->

<!-- ---- -->
<!-- ## Hierarchical Clustering -->

<!-- ![hierarchical](hierarchical.png) -->

<!-- * Task: Clustering -->
<!-- * Can produce hierarhical clusters -->
<!-- * Slower than k-Means -->
</script></section><section data-markdown><script type="text/template">## Ensemble Learning

![ensemble-learning](ensemble.png)

* Combine a set of low-accuracy (but cheaper to learn) models to
provide high-accuracy predictions
* Techniques:
  * Boosting (e.g., gradient boosting)
  * Bagging (random forest)
  * Stacking
</script></section><section data-markdown><script type="text/template">## Random Forest

![random-forest](random-forest.png)

* Randomly construct lots of decision trees
* Final output is the mode (for classification) or mean (regression) of 
  individual trees
* High accuracy & reduced overfitting; incremental (can add new trees)
* Reduced interpretability; large number of trees can take up space
</script></section><section data-markdown><script type="text/template">## Other Learning Methods

* Logistic regression 
* Support vector machine (SVM)
* Naive Bayes
* Principal component analysis (PCA)
* Markov networks
* Clustering methods
  * k-Means, hierarchical clustering
* Symbolic methods
  * Multi-agent systems
  * Logic-based representations
* and more...
</script></section></section><section ><section data-markdown><script type="text/template"># Tradeoff Analysis
</script></section><section data-markdown><script type="text/template">## Cost vs Benefit

![netflix-leaderboard](netflix-leaderboard.png)

_"We evaluated some of the new methods offline but the additional
accuracy gains that we measured did not seem to justify the
engineering effort needed to bring them into a production
environment.‚Äù_

<!-- references -->

_Netflix Recommendations: Beyond the 5 stars_, Amatriain & Basilico,
Netflix Technology Blog (2012)
</script></section><section data-markdown><script type="text/template">## Trade-offs: Accuracy vs Interpretability

![trade-offs](tradeoffs.png)

<!-- references -->

_Overcoming the Barriers to Production-Ready Machine Learning
Workflows_, Bloom & Brink, O'Reilly Strata Conference (2014).
</script></section><section data-markdown><script type="text/template">## Multi-Objective Optimization

![moo](moo.png)

* Determine optimal solutions given multiple, possibly
  **conflicting** objectives
* **Dominated** solution: A solution that is inferior to
  others in every way
* **Pareto frontier**: A set of non-dominated solutions 
</script></section><section data-markdown><script type="text/template">## Selecting Optimal ML Methods

1. Identify a set of constraints 
2. Eliminate methods that do not satisfy the constraints
3. For each type of attribute, evaluate remaining methods
4. Eliminate dominated methods
5. Consider priorities among attributes to select an optimal solution
</script></section><section data-markdown><script type="text/template">## Selection

![scikit-learn](ml_map.png)
</script></section></section><section  data-markdown><script type="text/template"># Summary

</script></section></div>
    </div>

    <script src="./../js/reveal.js"></script>

    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // Optional libraries used to extend on reveal.js
      var deps = [
        { src: './../lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: './../plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
        { src: './../plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: './../plugin/zoom-js/zoom.js', async: true },
        { src: './../plugin/notes/notes.js', async: true },
        { src: './../plugin/math/math.js', async: true }
      ];

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        dependencies: deps
      };

      // options from URL query string
      var queryOptions = Reveal.getQueryHash() || {};

      var options = extend(defaultOptions, {"controls":true,"progress":true,"theme":"white","slideNumber":true,"hash":true,"center":false}, queryOptions);
    </script>

    <script src="./../_assets/_assets/mermaid.min.js"></script>
    <script src="./../_assets/_assets/loadmymarkdown.js"></script>

    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
